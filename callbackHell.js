// ***********************************************************************************************************************
// **非同期処理の歴史概要**
// ***********************************************************************************************************************
// JavaScriptはシングルスレッドで動作するため、時間のかかる処理（ネットワークリクエスト、ファイルの読み込みなど）を同期的に実行すると、
// その間プログラムが停止してしまいます。

// そのため、非同期処理を行うためにコールバック関数が広く使われるようになりました。
// しかし、非同期処理が複雑になるにつれて、コールバック関数が深くネストする「コールバック地獄」と呼ばれる状態が発生しました。
// コールバック地獄は、コードの可読性や保守性を著しく低下させ、エラー処理も煩雑になるという問題を引き起こしました。

// コールバック地獄（Callback Hell）は、非同期処理をコールバック関数で多用することで、
// コードが深くネストし、可読性や保守性が著しく低下する現象です。

// ***********************************************************************************************************************
// **サンプルコード**
// ***********************************************************************************************************************

// 3つの非同期処理を順番に実行する例
function asyncTask1(callback) {
	setTimeout(() => {
		console.log('Task 1 completed');
		callback(null, 'result1'); // 成功時はnull, 結果を渡す
	}, 1000);
}

function asyncTask2(result1, callback) {
	setTimeout(() => {
		console.log('Task 2 completed with', result1);
		callback(null, 'result2');
	}, 1000);
}

function asyncTask3(result2, callback) {
	setTimeout(() => {
		console.log('Task 3 completed with', result2);
		callback(null, 'final result');
	}, 1000);
}

// コールバック地獄
// 右側にコードが膨れ上がっていく.....
// 可読性の低下、処理が複雑になっていく。
asyncTask1((err, result1) => {
	if (err) {
		console.error('Task 1 error:', err);
		return;
	}
	asyncTask2(result1, (err, result2) => {
		if (err) {
			console.error('Task 2 error:', err);
			return;
		}
		asyncTask3(result2, (err, finalResult) => {
			if (err) {
				console.error('Task 3 error:', err);
				return;
			}
			console.log('Final result:', finalResult);
		});
	});
});

// ***********************************************************************************************************************
// **コードの解説**
// ***********************************************************************************************************************

// 1.  **非同期処理の定義:**
//     asyncTask1, asyncTask2, asyncTask3 は、それぞれ非同期処理を模倣した関数です。
//     setTimeout を使用して、1秒後に処理が完了するようにしています。
//     各関数は、完了時に callback 関数を呼び出し、結果またはエラーを渡します。

// 2.  **コールバック地獄:**
//     asyncTask1 の完了後に asyncTask2 を実行し、asyncTask2 の完了後に asyncTask3 を実行するというように、コールバック関数が深くネストしています。
//     各コールバック関数内でエラー処理を行う必要があるため、コードが冗長になっています。
//     ネストが深くなるほど、コードの可読性が低下し、エラー処理が複雑になります。

// ***********************************************************************************************************************
// **コールバック地獄の問題点**
// ***********************************************************************************************************************

// 可読性の低下: ネストが深くなるほど、コードの構造が把握しにくくなります。
// 保守性の低下: コードの変更やデバッグが困難になります。
// エラー処理の複雑化: 各コールバック関数内でエラー処理を行う必要があるため、コードが冗長になります。
// 制御フローの把握が困難: 非同期処理の実行順序や依存関係が分かりにくくなります。

// ***** エラーの例 *********************************************************

// setTimeoutの中身はtry...catchブロックを抜けてから実行されるのでエラーをキャッチできない
// try {
// 	setTimeout(() => {
// 		throw new Error('エラーだよ');
// 	}, 1000);
// 	console.log('成功！', data);
// } catch (error) {
// 	console.error('catchでエラー！', error);
// }

// ***********************************************************************************************************************
// **コールバック地獄からPromiseが生まれた経緯**
// ***********************************************************************************************************************

// コールバック地獄の問題を解決するために、よりシンプルで扱いやすい非同期処理の仕組みが求められました。
// そこで登場したのがPromiseです。Promiseは、非同期処理の結果（成功または失敗）を表現するオブジェクトであり、以下のような特徴を持ちます。

// **非同期処理の結果を後から取得できる**
// 　.then()や.catch()などのメソッドを使って、非同期処理の完了時やエラー発生時の処理を記述できる

// **複数の非同期処理をチェーン化して、順次実行できる**

// Promiseは、コールバック地獄を回避し、非同期処理をよりシンプルに記述するための強力なツールとして、JavaScriptに導入されました。
// そして、Promiseによって非同期処理が扱いやすくなったことで、より複雑で高度な非同期処理をJavaScriptで記述することが可能になりました。
